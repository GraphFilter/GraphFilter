{
  "dic": [
    {
      "name": "Chromatic Number",
      "definition" : "It's the smallest number of colors needed to color the vertices of G so that no two adjacent vertices share the same color",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/ChromaticNumber.html",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Chromatic Index (edge)",
      "definition" : "It's the smallest number of colors needed to color the edges of G so that no two adjacent edges share the same color",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Edge_coloring",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Number of vertices",
      "definition" : "Number of vertices",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Number of Edges",
      "definition" : "Number of Edges",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Clique (number and set)",
      "definition" : "A clique is a subset of nodes in which each pair of nodes is adjacent. The clique number of a graph G is the number of vertices in a maximum clique in G.",
      "usage": "For filtering click on the <b>Clique Number</b> button in the equation to use it. Or in Visualization you can check <b>Clique Number</b> or <b>Maximum Clique Set</b> in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Clique_(graph_theory)",
      "implementation": "Grinpy and Netowrokx Python library"
    },
    {
      "name": "Independence (number and set)",
      "definition" : "Independent set or stable set is a set of vertices in a graph, no two of which are adjacent. The independence number of a graph G is the number of vertices in a maximum independent set in G.",
      "usage": "For filtering click on the <b>Independence Number</b> button in the equation to use it. Or in Visualization you can check <b>Independence Number</b> or <b>Maximum Independence Set</b> in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Independent_set_(graph_theory)",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Domination (number and set)",
      "definition" : "A dominating set for a graph G=(V, E) is a subset D of V such that every vertex not in D is adjacent to at least one member of D. The domination number is the number of vertices in a smallest dominating set for G.",
      "usage": "For filtering click on '<b>Domination number</b>' button in the equation to use it. Or in Visualization you can check '<b>Domination number</b>' or '<b>Domination set</b>' in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/DominationNumber.html",
      "implementation": "Grinpy and Networkx Python library"
    },
    {
      "name": "Total Domination Number",
      "definition" : "The total domination number of a graph is the size of a smallest total dominating set, where a total dominating set is a set of vertices of the graph such that all vertices (including those in the set itself) have a neighbor in the set. Total dominating numbers are defined only for graphs having no isolated vertex",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/TotalDominationNumber.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Connected Domination Number",
      "definition" : "The connected domination number of a connected graph G, denoted d(G), is the size of a minimum connected dominating set of a graph G. A connected dominating set in a connected graph G is a dominating set in G whose vertices induce a connected subgraph",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/ConnectedDominatingSet.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Matching Number",
      "definition" : "A matching in a graph is a set of edges in which no two distinct edges share a common endpoint. The matching number of graph G, or edge independence number, is the size of a maximum independent edge set. ",
      "usage": "For filtering click on the <b>Matching Number</b> button in the equation to use it. Or in Visualization you can check <b>Matching Number</b> or <b>Maximum Matching Set</b> in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/MatchingNumber.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Vertex Connectivity",
      "definition" : "It's the minimum number of nodes that must be removed to disconnect the graph or render it trivial.",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/VertexConnectivity.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Edge Connectivity",
      "definition" : "It's the minimum number of edges that must be removed to disconnect the graph.",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/EdgeConnectivity.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Number of components",
      "definition" : "It's the number of maximals componnents in the graph",
      "usage": "For filtering click on the respective button in the equation to use it..  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Component_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Degree regularity",
      "definition" : "It's the number of distinct values in the sequence of degrees of the graph.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/VertexDegree.html",
      "implementation": ""
    },
    {
      "name": "Maximum Degree",
      "definition" : "It's the largest vertex degree of G",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/VertexDegree.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Minimum Degree",
      "definition" : "It's the smallest vertex degree of G",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/VertexDegree.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Average Degree",
      "definition" : "It's the average degree per vertex in the graph",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/VertexDegree.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Girth",
      "definition" : "It's the length of a shortest cycle contained in the graph.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Girth_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Edge Cover",
      "definition" : "An edge cover of a graph is a set of edges such that every vertex of the graph is incident to at least one edge of the set. The <b>minimum edge cover (set)</b> is an edge covering of smallest cardinality.",
      "usage": "For filtering click on the respective button in the equation to use <b>minimum edge cover number</b>.  Or in Visualization you can check <b>minimum edge cover number</b> or <b>edge cover</b>  in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Edge_cover",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Vertex Cover Number",
      "definition" : " It's the size of a minimum vertex cover. A vertex cover (or node cover) of a graph is a set of vertices that includes at least one endpoint of every edge of the graph. ",
      "usage": "FFor filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/VertexCover.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Diameter",
      "definition" : "It's the greatest distance between any pair of vertices.",
      "usage": "For filtering click on the respective button in the equation to use it. Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Distance_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Radius",
      "definition" : "The radius r of a graph is the minimum eccentricity of any vertex. The eccentricity of a vertex is the greatest distance between it and any other vertex.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Distance_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Adjacency Matrix - A",
      "definition" : "It's a square (0,1)-matrix whose elements indicate whether pairs of vertices are adjacent, with the value 1, or not, with the value 0.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Adjacency_matrix",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Laplacian Matrix - L",
      "definition" : "It's L=D-A, where D is the diagonal matrix of node degrees and A is the adjacency matrix of the graph.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Laplacian_matrix",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Signless Laplacian Matrix - Q",
      "definition" : "It's L=D+A, where D is the diagonal matrix of node degrees and A is the adjacency matrix of the graph.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Laplacian_matrix#Signless_Laplacian",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Normalized Laplacian Matrix - N",
      "definition" : "It's the matrix N=D<sup>\u00bd</sup>LD<sup>\u00bd</sup>, where L is the Laplacian matrix and D is the diagonal matrix of node degrees.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Laplacian_matrix#Symmetric_normalized_Laplacian",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Incidence Matrix",
      "definition" : "It's a (0,1)-matrix which has a row for each vertex and column for each edge, and an entry (v,e)=1 iff vertex v is incident upon edge e.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/IncidenceMatrix.html",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Distance Matrix - D",
      "definition" : "It's square matrix containing the distances, taken pairwise, between the vertices.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Distance_matrix",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Seidel Matrix - S",
      "definition" : "It's square matrix S=J-I-2A, where J is the matrix formed by 1, A is the adjacency matrix and I the identity matrix",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Seidel_adjacency_matrix",
      "implementation": "own implementation"
    },
    {
      "name": "Laplacian Distance Matrix - DL",
      "definition" : "It's square matrix DL=Diag(Tr)−D, where Diag(Tr) is the diagonal matrix of the vertex transmissions and D is the distance matrix.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://doi.org/10.1016/j.laa.2013.02.030",
      "implementation": "own implementation"
    },
        {
      "name": "Signless Laplacian Distance Matrix - DQ",
      "definition" : "It's square matrix DL=Diag(Tr)+D, where Diag(Tr) is the diagonal matrix of the vertex transmissions and D is the distance matrix.",
      "usage": "In Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://doi.org/10.1016/j.laa.2013.02.030",
      "implementation": "own implementation"
    },
    {
      "name": "Largest M-eigenvalue",
      "definition" : "It's the largest eigenvalue of matrix M.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Adjacency_matrix",
      "implementation": "Numpy Python library"
    },
    {
      "name": "Algebraic Connectivity",
      "definition" : "It's the second-smallest eigenvalue (counting multiple eigenvalues separately) of the Laplacian matrix of G. This is L=D-A, where D is the degree matrix and A is the adjacency matrix of the graph.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Algebraic_connectivity",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Energy [matrix M]",
      "definition" : "Energy of a graph is E= \u03a3 |\u03bb - Tr(M)/n|, where \u03a3 are the eigenvalues of M, Tr(M) is the trace of matrix and n the order.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_energy",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Some M-eigenvalue integer",
      "definition" : "Checks if there is an integer M-eigenvalue",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "none",
      "implementation": "own implementation"
    },
    {
      "name": "Spectrum [matrix M]",
      "definition" : "It's the set of eigenvalues of matrix M",
      "usage": "In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "none",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Eigenvectors [matrix M]",
      "definition" : "It is the set of eigenvectors and their eigenvalues in the matrix M",
      "usage": "In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "none",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "M-integral",
      "definition" : "Checks if all M-eigenvalues are integer.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "none",
      "implementation": "own implementation"
    },
    {
      "name": "Rank of matrix M",
      "definition" : "This corresponds to the maximal number of linearly independent columns of matrix M.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Rank_(linear_algebra)",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Invertible matrix M",
      "definition" : "Check if matrix M is invertible.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Invertible_matrix",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Determinant of matrix M",
      "definition" : "Calculates the determinant of matrix M.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Determinant",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Largest M-eigenvalue is integer",
      "definition" : "Checks whether the largest M-eigenvalue is an integer.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "none",
      "implementation": "own implementation"
    },
    {
      "name": "Main M-eigenvalue (number of)",
      "definition" : "The eigenvalue x of a matrix M is said to be a main eigenvalue of G, if the eigenspace E(x) is not orthogonal to the all-1 vector.",
      "usage": "For filtering click on the respective button in the equation to use it and get the number of main eigenvalues.  Or in Visualization you can check '<b>number of main M-eigenvalues</b>' or '<b>main M-eigenvalues (set)</b>' in the invariants menu to calculate in the plotted graph",
      "link": "http://pefmath.etf.rs/vol1num2/AADM-Vol1-No2-455-471.pdf",
      "implementation": "Numpy and own implementation"
    },
    {
      "name": "Wiener Index",
      "definition" : "The Wiener index (or the \"path number\") is a graph index defined for a graph on n nodes by W=\u00bd\u03a3\u03a3 d(i,j), where d(i,j) is the distance between the vertices i and j.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/WienerIndex.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Estrada Index",
      "definition" : "It's a graph index defined for a graph on n nodes by EE=\u03a3 e<sup>\u03bb</sup>, where \u03bb are the eigenvalues of adjacency matrix.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Estrada_index",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Nullity",
      "definition" : "In the matrix theory of graphs, the nullity of the graph is the nullity of the adjacency matrix A of the graph. This nullity equals the multiplicity of the eigenvalue 0 in the spectrum of the adjacency matrix",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Nullity_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Number spanning trees",
      "definition" : "The number of spanning trees of a connected graph G. A spanning tree T of an undirected graph G is a subgraph that is a tree which includes all of the vertices of G. This invariant can be obtained from Kirchhoff's theorem.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Spanning_tree",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Density",
      "definition" : "The graph density of simple graphs is defined to be the ratio of the number of edges with respect to the maximum possible edges The density is 0 for a graph without edges and 1 for a complete graph.",
      "usage": "For filtering click on the respective button in the equation to use it.  Or in Visualization you can check it in the invariants menu to calculate in the plotted graph",
      "link": "https://networkx.org/documentation/networkx-1.10/reference/generated/networkx.classes.function.density.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Planar",
      "definition" : "It's a graph that can be embedded in the plane, i.e., it can be drawn on the plane in such a way that its edges intersect only at their endpoints.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Planar_graph",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Connected",
      "definition" : "There is a path from any point to any other point in the graph. ",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://mathworld.wolfram.com/ConnectedGraph.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Biconnected",
      "definition" : "A graph is biconnected if, and only if, it cannot be disconnected by removing only one node (and all edges incident on that node).",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.is_biconnected.html#networkx.algorithms.components.is_biconnected",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Bipartite",
      "definition" : "It's a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Bipartite_graph",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Has bridge",
      "definition" : "A bridge is an edge of a graph whose deletion increases the graph's number of connected components.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Bridge_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Eulerian",
      "definition" : "It's a graph that has an Eulerian cycle. An Eulerian cycle (Eulerian circuit or Euler tour) in an undirected graph is a cycle that uses each edge exactly once..",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Eulerian_path#Definition",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Chordal",
      "definition" : "It's one in which all induced cycle in the graph should have exactly three vertices.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Chordal_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Triangle-free",
      "definition" : "It's a graph in which no three vertices form a triangle of edges.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Triangle-free_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Bull-free",
      "definition" : "The bull graph is a triangle with two disjoint pendant edges.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Bull_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Regular graph",
      "definition" : "It's a graph where each vertex has the same number of neighbors; i.e. every vertex has the same degree",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Regular_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Cubic graph",
      "definition" : "It's a regular graph with vertices of degree 3.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Cubic_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Transmission",
      "definition" : "For each vertex, it calculates the sum of its distances from the other vertices. A graph is Regular Transmission if all sums has the same value.",
      "usage": "For filtering, you can check True (or False) in the Regular Transmission, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check the <b>Transmission</b> or <b>Regular Transmission</b> in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Cubic_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Self-complementary graph",
      "definition" : "A self-complementary graph is a graph which is isomorphic to its complement.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Self-complementary_graph",
      "implementation": "Networkx Python library"
    },
    {
      "name": "Complement",
      "definition" : "The complement of a graph G is a graph Comp(G) on the same vertices such that two distinct vertices of c(G) are adjacent if and only if they are not adjacent in G.",
      "usage": "For filtering click on the respective button in the equation to use it",
      "link": "https://en.wikipedia.org/wiki/Complement_graph",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Line graph",
      "definition" : "The line graph of an undirected graph G is another graph \u2113(G) that represents the adjacencies between edges of G. It's constructed in the following way: for each edge in G, make a vertex in \u2113(G); for every two edges in G that have a vertex in common, make an edge between their corresponding vertices in \u2113(G).",
      "usage": "For filtering click on the respective button in the equation to use it",
      "link": "https://en.wikipedia.org/wiki/Line_graph",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Clique graph",
      "definition" : "Returns the clique graph of the graph. The nodes of the clique graph \u0198(G) are the maximal cliques of G and an edge joins two cliques if the cliques are not disjoint.",
      "usage": "For filtering click on the respective button in the equation to use it",
      "link": "http://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.clique.make_max_clique_graph.html?highlight=clique%20max",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Degree Centrality",
      "definition" : "For each vertex its degree is calculated",
      "usage": "In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Centrality#Degree_centrality",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Eigenvector Centrality",
      "definition" : "For node i is the i-th element of the normalized eigenvector associated with the largest adjacency eigenvalue",
      "usage": "In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Centrality#Eigenvector_centrality",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Closeness Centrality",
      "definition" : "For each node is the average length of the shortest path between the node and all other nodes in the graph.",
      "usage": "In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "http://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Betweenness Centrality",
      "definition" : "For each nodes computes the number of times the node acts as a bridge along the shortest path between two other nodes.",
      "usage": "In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Centrality#Betweenness_centrality",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Harmonic Centrality",
      "definition" : "For each vertex computes the sum of the inverses of the distances from this vertex to the rest of the graph is calculated.",
      "usage": "In Visualization, you can check it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Centrality#Harmonic_centrality",
      "implementation": "NetworkX Python Library"
    }

  ]
}