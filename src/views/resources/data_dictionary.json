{
  "dic": [
    {
      "name": "Chromatic Number",
      "definition" : "The chromatic number of a graph \u0246 is the smallest number of colors needed to color the vertices of $G$ so that no two adjacent vertices share the same color, denoted by $chi(G)$.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_coloring",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Number of vertices",
      "definition" : "Number of vertices",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Number of Edges",
      "definition" : "Number of Edges",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Clique Number",
      "definition" : "The clique number $omega(G)$ of a graph $G$ is the number of vertices in a maximum clique in $G$.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Clique_(graph_theory)",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Independence Number",
      "definition" : "The independence number of a graph $G$ is the number of vertices in a maximum independent set in G.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Independent_set_(graph_theory)",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Domination Number",
      "definition" : "The domination number is the number of vertices in a smallest dominating set for $G$. A dominating set for a graph $G=(V, E)$ is a subset $D$ of $V$ such that every vertex not in $D$ is adjacent to at least one member of $D$.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Dominating_set",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Total Domination Number",
      "definition" : "The total domination number $$gamma_t$$ of a graph is the size of a smallest total dominating set, where a total dominating set is a set of vertices of the graph such that all vertices (including those in the set itself) have a neighbor in the set. Total dominating numbers are defined only for graphs having no isolated vertex",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/TotalDominationNumber.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Connected Domination Number",
      "definition" : "The connected domination number of a connected graph $G$, denoted $d(G)$, is the size of a minimum connected dominating set of a graph $G$. A connected dominating set in a connected graph $G$ is a dominating set in $G$ whose vertices induce a connected subgraph",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/ConnectedDominatingSet.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Matching Number",
      "definition" : "The matching number $u(G)$ of graph $G$, sometimes known as the edge independence number, is the size of a maximum independent edge set. ",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Matching_(graph_theory)",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Vertex Connectivity",
      "definition" : "The vertex connectivity $kappa(G)$ of a graph $G$, also called \"point connectivity\" or simply \"connectivity,\" is the minimum size of a vertex cut, i.e., a vertex subset $Ssubset V(G)$ such that $G-S$ is disconnected or has only one vertex.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/VertexConnectivity.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Edge Connectivity",
      "definition" : "The minimum number of edges $lambda(G)$ whose deletion from a graph $G$ disconnects $G$, also called the line connectivity.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/EdgeConnectivity.html",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Number of componnents",
      "definition" : "It's the number of maximals componnents in the graph",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Component_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Degree regularity",
      "definition" : "It's the number of distinct values in the sequence of degrees of the graph.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": ""
    },
    {
      "name": "Maximum Degree",
      "definition" : "It's the number of distinct values in the sequence of degrees of the graph.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Minimum Degree",
      "definition" : "Minimum Degree",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Average Degree",
      "definition" : "Average Degree",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Graph_theory",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Vertex Cover Number",
      "definition" : " It's the size of a minimum vertex cover, denoted by $tau(G)$. A vertex cover (or node cover) of a graph is a set of vertices that includes at least one endpoint of every edge of the graph. ",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Vertex_cover",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Diameter",
      "definition" : "It's the greatest distance between any pair of vertices.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Distance_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Radius",
      "definition" : "The radius r of a graph is the minimum eccentricity of any vertex. The eccentricity of a vertex $v$ is the greatest distance between v and any other vertex.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Distance_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Largest A-eigenvalue",
      "definition" : "It's the largest eigenvalue of adjacency matrix. ",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Adjacency_matrix",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Largest L-eigenvalue",
      "definition" : "It's the largest eigenvalue of Laplacian matrix, this is $L=D-A$, where D is the degree matrix and A is the adjacency matrix of the graph.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Laplacian_matrix",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Largest Q-eigenvalue",
      "definition" : "It's the largest eigenvalue of Signless Laplacian matrix. Given a simple graph G with n vertices, its Signless Laplacian matrix is Q=D+A, where D is the degree matrix and A is the adjacency matrix of the graph.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Laplacian_matrix#Signless_Laplacian",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Largest D-eigenvalue",
      "definition" : "It's the largest eigenvalue of graph distance matrix. This matrix is the square where each entry (i,j) represents the distance between the vertices i and j.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/GraphDistanceMatrix.html",
      "implementation": "Numpy and NetworkX python Library"
    },
    {
      "name": "Algebraic Connectivity",
      "definition" : "It's the second-smallest eigenvalue (counting multiple eigenvalues separately) of the Laplacian matrix of G. This is L=D-A, where D is the degree matrix and A is the adjacency matrix of the graph.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Algebraic_connectivity",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Wiener Index",
      "definition" : "The Wiener index (or the \"path number\") is a graph index defined for a graph on $n$ nodes by $W=frac{1}{2}sum_{i=1}^{n} sum_{j=1}^{n}d(i,j)$, where $d(i,j)$ is the graph distance matrix, with the distance between the vertices $i$ and $j$.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://mathworld.wolfram.com/WienerIndex.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Estrada Index",
      "definition" : "It's a graph index defined for a graph on $n$ nodes by $EE(G)=sum _{j=1}^{n}e^{lambda _{j}, where $lambda_i$ is the eigenvalue of adjancecy matrix.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Estrada_index",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Nullity",
      "definition" : "In the matrix theory of graphs, the nullity of the graph is the nullity of the adjacency matrix $A$ of the graph. The nullity of $A$ is given by $n − r$ where, $r$ is the rank of the adjacency matrix.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Nullity_(graph_theory)",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Number spanning trees",
      "definition" : "The number $t(G)$ of spanning trees of a connected graph $G$. A spanning tree $T$ of an undirected graph $G$ is a subgraph that is a tree which includes all of the vertices of $G$. This invariant can be obtained from Kirchhoff's theorem.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Spanning_tree",
      "implementation": "Numpy Python Library"
    },
    {
      "name": "Density",
      "definition" : "It's the number $den(G)=frac{2m}{n(n-1)}$, where $m$ and $n$ are the number of edges and nodes, in order. The density is 0 for a graph without edges and 1 for a complete graph.",
      "usage": "For filtering write the X code in the equation to use it.  Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://networkx.org/documentation/networkx-1.10/reference/generated/networkx.classes.function.density.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Planar",
      "definition" : "It's a graph that can be embedded in the plane, i.e., it can be drawn on the plane in such a way that its edges intersect only at their endpoints.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Planar_graph",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Connected",
      "definition" : "There is a path from any point to any other point in the graph. ",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://mathworld.wolfram.com/ConnectedGraph.html",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Biconnected",
      "definition" : "A graph is biconnected if, and only if, it cannot be disconnected by removing only one node (and all edges incident on that node).",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.is_biconnected.html#networkx.algorithms.components.is_biconnected",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Bipartite",
      "definition" : "It's a graph whose vertices can be divided into two disjoint and independent sets $U$ and $V$ such that every edge connects a vertex in $U$ to one in $V$.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Bipartite_graph",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Eulerian",
      "definition" : "It's a graph that has an Eulerian cycle. An Eulerian cycle (Eulerian circuit or Euler tour) in an undirected graph is a cycle that uses each edge exactly once..",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Eulerian_path#Definition",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Chordal",
      "definition" : "It's one in which all induced cycle in the graph should have exactly three vertices.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Chordal_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Triangle-free",
      "definition" : "It's a graph in which no three vertices form a triangle of edges.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Triangle-free_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Regular graph",
      "definition" : "It's a graph where each vertex has the same number of neighbors; i.e. every vertex has the same degree",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Regular_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "k-regular graph",
      "definition" : "It's a regular graph with vertices of degree $k$.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "https://en.wikipedia.org/wiki/Regular_graph",
      "implementation": "Grinpy Python library"
    },
    {
      "name": "Some M -eigenvalue integer",
      "definition" : "Checks if there is an integer M-eigenvalue, where $M=A, L, Q or D$.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "",
      "implementation": ""
    },
    {
      "name": "M-integral",
      "definition" : "Checks if all M-eigenvalues are integer, where $M=A, L, Q or D$.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "",
      "implementation": ""
    },
    {
      "name": "Largest M-eigenvalue is integer",
      "definition" : "Checks whether the largest M-eigenvalue is an integer, where $M=A, L, Q or D$.",
      "usage": "For filtering, you can check True (or False) in the respective line, if you want the condition to be satisfied (or not) in the graphs to be filtered. No checks so that filtering does not use this invariant. In Visualization, you can mark it in the invariants menu to calculate in the plotted graph.",
      "link": "",
      "implementation": ""
    },
    {
      "name": "Complement",
      "definition" : "The complement of a graph G is a graph H on the same vertices such that two distinct vertices of H are adjacent if and only if they are not adjacent in G.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Complement_graph",
      "implementation": "NetworkX Python Library"
    },
    {
      "name": "Line graph",
      "definition" : "The line graph of an undirected graph $G$ is another graph $ell(G)$ that represents the adjacencies between edges of $G$. $ell(G)$ is constructed in the following way: for each edge in $G$, make a vertex in $ell(G)$; for every two edges in $G$ that have a vertex in common, make an edge between their corresponding vertices in $ell(G)$.",
      "usage": "For filtering write the X code in the equation to use it. Or in Visualization you can mark it in the invariants menu to calculate in the plotted graph",
      "link": "https://en.wikipedia.org/wiki/Line_graph",
      "implementation": "NetworkX Python Library"
    }
  ]
}